# 程序的机器级表示

## 机器级代码

- 计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。
  - 第一种是由指令集体系结构或指令集架构(`Instruction Set Architecture,ISA`)来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
  - 第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。
- C语言编译过程中，将把用C语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。
- 汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。
  - `x86-64`的机器代码和原始的C代码差别非常大。一些通常对C语言程序员隐藏的处理器状态都是可见的。
    - 程序计数器(通常称为"PC"，在`x86-64`中用`%rip`表示)给出将要执行的下一条指令在内存中的地址。
    - 整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（对应于C语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
    - 条件码寄存器来保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现`if`和`which`语句。
    - 一组向量寄存器可以存放一个或多个整数或浮点数值。
- 虽然C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码知识简单地将内存看成一个很大的、按字节寻址地数组。C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。

### x86指令特点

- `x86-64`的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。
- 反汇编器只是基于机器代码文件中地字节序列来确定汇编代码。它不需要访问该程序地源代码或汇编代码
- 反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微的差别。

## 数据格式

- 字(`word`)表示16位数据类型。因此，称32位数为"双字(`double words`)"，称64位数为"四字(`quand words`)"。

  - | C声明    | Intel数据类型 | 汇编代码后缀 | 大小（字节） |
    | -------- | ------------- | ------------ | ------------ |
    | `char`   | 字节          | `b`          | `1`          |
    | `short`  | 字            | `w`          | `2`          |
    | `int`    | 双字          | `l`          | `4`          |
    | `long`   | 四字          | `q`          | `8`          |
    | `char*`  | 四字          | `q`          | `8`          |
    | `float`  | 单精度        | `s`          | `4`          |
    | `double` | 双精度        | `l`          | `8`          |

## 访问信息

- 一个`x86-64`的中央处理单元(`CPU`)包含一组16个存储64位值的通用目的寄存器。
  - 最初的8060中有8个16位的寄存器，`%ax`到`%sp`。扩展到`x86-64`后，原来的8个寄存器扩展成64位，标号从`%rax`到'%rsp'。除此之外，还新增了8个新的寄存器，标号是按照新的命名规则制定的：从`%r8`到`%r15`

### 操作数指示符

- 大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。各种不同的操作数的可能性被分为三种类型。

  - 第一种类型是立即数（`immediate`）：用来表示常数值。立即数的书写方式是'\$'后面跟一个用标准C表示法表示的整数。

  - 第二种类型是寄存器(`register`)：它表示某个寄存器的内容。用符号$r_a$来表示任意寄存器$a$，用引号$R[r_a]$来表示它的值，这是将寄存器集合看成一个数组`R`，用寄存器标识符作为索引。

  - 第三类操作数是内存引用，他会根据计算出来的地址(通常称为有效地址)访问某个内存位置。用符号$M_b[Addr]$表示对存储在内存中从地址$Addr$开始的`b`个字节值的引用。为了方便，通常省去下标`b`。

    - | 类型   | 格式             | 操作数值                 | 名称              |
      | ------ | ---------------- | ------------------------ | ----------------- |
      | 立即数 | $\$Imm$          | $Imm$                    | 立即数寻址        |
      | 寄存器 | $r_a$            | $R[r_a]$                 | 寄存器寻址        |
      | 存储器 | $Imm$            | $M[Imm]$                 | 绝对寻址          |
      | 存储器 | $r_a$            | $M[R[r_a]]$              | 间接寻址          |
      | 存储器 | $Imm(r_b)$       | $M[Imm+R[r_b]]$          | (基址+偏移量)寻址 |
      | 存储器 | $(r_b,r_i)$      | $M[R[r_b]+R[r_i]]$       | 变址寻址          |
      | 存储器 | $Imm(r_b,r_i)$   | $M[Imm+R[r_b]+R[r_i]]$   | 变址寻址          |
      | 存储器 | $(,r_b,r_i)$     | $M[R[r_i]*s]$            | 比例变址寻址      |
      | 存储器 | $Imm(,r_i,s)$    | $M[Imm+R[r_i]*s]$        | 比例变址寻址      |
      | 存储器 | $(r_b,r_i,s)$    | $M[R[r_b]+R[r_i]*s]$     | 比例变址寻址      |
      | 存储器 | $Imm(r_b,r_i,s)$ | $M[Imm+R[r_b]+R[r_i]*s]$ | 比列变址寻址      |


### 数据传输指令

- 将数据从一个位置复制到另一个位置的指令。

- `MOV`类。这些指令把数据从源位置复制到目的位置，不做任何变化。

  - | 指令           | 效果     | 描述           |
    | -------------- | -------- | -------------- |
    | `MOV     S,D`  | `D <- S` | 传送           |
    | `movb`         |          | 传送字节       |
    | `movw`         |          | 传送字         |
    | `movl`         |          | 传送双字       |
    | `movq`         |          | 传送四字       |
    | `moabsq   I,R` | `R <- I` | 传送绝对的四字 |

- `MOVZ`类中的指令把目的中剩余的字节填充为0，而`MOVS`类中的指令通过符号扩展来填充，把源操作的最高位进行复制

  - | 指令         | 效果             | 描述                         |
    | ------------ | ---------------- | ---------------------------- |
    | `MOVZ   S,R` | `R <- 零扩展(S)` | 以零扩展进行传送             |
    | `movzbw`     |                  | 将做了零扩展的字节传送到字   |
    | `movzbl`     |                  | 将做了零扩展的字节传送到双字 |
    | `movzwl`     |                  | 将做了零扩展的字传送到双字   |
    | `movzbq`     |                  | 将做了零扩展的字节传送到四字 |
    | `movzwq`     |                  | 将做了零扩展的字传送到四字   |

    - 零扩展数据传送指令。这些指令以寄存器或内存地址作为源，以寄存器作为目的

  - | 指令       | 效果                     | 描述                           |
    | ---------- | ------------------------ | ------------------------------ |
    | `MOVS S,R` | `R <- 符号扩展(S)`       | 传送符号扩展的字节             |
    | `movsbw`   |                          | 将做了符号扩展的字节传送到字   |
    | `movsbl`   |                          | 将做了符号扩展的字节传送到双字 |
    | `movswl`   |                          | 将做了符号扩展的字传送到双字   |
    | `movsbq`   |                          | 将做了符号扩展的字节传送到四字 |
    | `movswq`   |                          | 将做了符号扩展的字传送到四字   |
    | `movslq`   |                          | 将做了符号扩展的双字传送到四字 |
    | `cltq`     | `%rax <- 符号扩展(%eax)` | 把`%eax`符号扩展到`%rax`       |

### 压入和弹出栈数据

- 两个数据传送操作可以将数据压入程序栈中，以及从程序栈中弹出数据。栈指针`%rsp`保存着栈顶元素的地址。

  - | 指令        | 效果                                          | 描述         |
    | ----------- | --------------------------------------------- | ------------ |
    | `pushq   S` | $R[\%rsp]<-R[\%rsp]-8$;<br />$M[R[\%rsp]]<-S$ | 将四字压入栈 |
    | `popq    D` | $D<-M[R[\%rsp]]$<br />$R[\%rsp]<-R[\%rsp]+8$  | 将四字弹出栈 |

    - 将一个四字值压入栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。
    - 弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加8.

## 算术和逻辑操作

- | 指令       | 效果                      | 描述              |
  | ---------- | ------------------------- | ----------------- |
  | `leaq S,D` | $D <-\&S$                 | 加载有效地址      |
  | `INC D`    | $D<-D+1$                  | 加1               |
  | `DEC D`    | $D<-D-1$                  | 减1               |
  | `NEG D`    | $D<-D$                    | 取负              |
  | `NOT D`    | $D<--D$                   | 取补              |
  | `ADD S,D`  | $D<-D+S$                  | 加                |
  | `SUB S,D`  | $D<-D-S$                  | 减                |
  | `IMUL S,D` | $D<-D*S$                  | 乘                |
  | `XOR S,D`  | $D<-D \textasciicircum S$ | 异或              |
  | `OR S,D`   | $D<D|S$                   | 或                |
  | `AND S,D`  | $D<D\&S$                  | 与                |
  | `SAL k,D`  | $D<D<<k$                  | 左移              |
  | `SHL k,D`  | $D<D<<k$                  | 左移(等同于`SAL`) |
  | `SAR k,D`  | $D<D>>_Ak$                | 算术右移          |
  | `SHR k,D`  | $D<D>>_Lk$                | 逻辑右移          |

### 加载有效地址

- 将有效地址写入到目的操作数

### 一元和二元操作

- 一元操作，只有一个操作数，既是源又是目的。
- 二源操作，第二个操作数既是源又是目的。

### 移位操作

- 最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。移位量可以是一个立即数，或者放在单字节寄存器$\%cl$中。（这些指令很特别，因为只允许以这个特定的寄存器作为操作数。）

### 特殊的算术操作

- 两个64位有符号或无符号整数相乘得到的乘机需要128位来表示。

  - | 指令                      | 效果                                                         | 描述                           |
    | ------------------------- | ------------------------------------------------------------ | ------------------------------ |
    | `imulq  S`<br />`mulq  S` | $R[\%rdx]:R[\%rax]<-S*R[\%rax]$<br />$R[\%rdx]:R[\%rax]<-S*R[\%rax]$ | 有符号全乘法<br />无符号全乘法 |
    | `cqto`                    | $R[\%rdx]:R[\%rax]<-符号扩展(R[\%rax])$                      | 转换为八字                     |
    | `idivq  S`                | $R[\%rax]<-R[\%rdx]:R[\%rax]~mod~S$<br />$R[\%rax]<-R[\%rdx]:R[\%rax]~÷~S$ | 有符号除法                     |
    | `divq  S`                 | $R[\%rdx]<-R[\%rdx]:R[\%rax]~mod~S$<br />$R[\%rax]<-R[\%rdx]:R[\%rax]~÷~S$ | 无符号除法                     |

    - 无符号乘法和补码乘法都要求一个参数必须在寄存器$\%rax$中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器$\%rdx$（高64位）和`%rax`（低64位）中。
    - 有符号除法指令`idivl`将寄存器$\%rdx$（高64位）和$\%rax$（低64位）中的128位数作为被除数，而除数作为指令的操作数给出。

## 控制

- 机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。

### 条件码

- `CPU`维护着一组单个位的条件码(`condition code`)寄存器，它们描述了最近的算术或逻辑操作的属性。

  - `CF`：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
  - `ZF`：零标志。最近的操作得出的结果为0
  - `SF`：零号标志。最近的操作得到的结果为负数。
  - `OF`：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。
  
- 条件码通常不会直接取数，常用的使用方法有三种：

  1. 可以根据条件码的某种组合，将一个字节设置为0或者1
  2. 可以条件跳转到程序的某个其他的部分
  3. 可以有条件的传送数据

- 对于第一种情况，可以根据条件码的某种组合，将一个字节设置为0或者1.这一整类指令称为`SET`指令。

  - | 指令       | 同义名   | 效果                                         | 设置条件             |
    | ---------- | -------- | -------------------------------------------- | -------------------- |
    | `sete  D`  | `setz`   | $D<-ZF$                                      | 相等/零              |
    | `setne`    | `setnz`  | $D<-ZF$                                      | 不等/非零            |
    | `sets  D`  |          | $D<SF$                                       | 负数                 |
    | `setns  D` |          | $D<-SF$                                      | 非负数               |
    | `setg  D`  | `setnle` | $D< \sim(SF ~\textasciicircum DF)\&~\sim ZF$ | 大于(有符号>)        |
    | `setge  D` | `setnl`  | $D<\sim~(SF~\textasciicircum DF)$            | 大于等于(有符号>=)   |
    | `setl  D`  | `setnge` | $D<-SF~\textasciicircum DF$                  | 小于(有符号<)        |
    | `setle  D` | `setng`  | $D<-(SF~\textasciicircum DF)|ZE$             | 小于等于(有符号<=)   |
    | `seta  D`  | `setnbe` | $D<\sim CF~\& \sim ZF$                       | 超过(无符号>)        |
    | `setae  D` | `setnb`  | $D<-\sim CF$                                 | 超过或相等(无符号>=) |
    | `setb  D`  | `setnae` | $D<-CF$                                      | 低于(无符号<)        |
    | `setbe  D` | `setna`  | $D<-CF|ZF$                                   | 低于或相等(无符号<=) |

    


### CMP和TEST

- `CMP`指令根据两个操作数之差来设置条件码

- `TEST`指令的行为与`AND`指令一样，除了它们只设置条件码而不改变目的寄存器的值。

  - | 指令                                                         | 基于          | 描述                                                       |
    | ------------------------------------------------------------ | ------------- | ---------------------------------------------------------- |
    | $CMP~~S_1,S_2$<br />`cmpb`<br />`cmpw`<br />`cmpl`<br />`cmpq` | $S_1~~-~~S_2$ | 比较<br />比较字节<br />比较字<br />比较双字<br />比较四字 |
    | $TEST~~S_1,S_2$<br />`testb`<br />`testw`<br />`testl`<br />`testq` | $S_1\&S_2$    | 测试<br />测试字节<br />测试字<br />测试双字<br />测试四字 |

### 跳转指令

- 正常执行的情况下，指令按照它们出现的顺序一条一条地执行。跳转(`jump`)指令会导致执行切换到程序中的一个全新的位置。

- 指令`jmp .L1`会导致程序跳过`movq`指令，而从`popq`指令开始继续执行。

- `jmp`指令可以是无条件跳转。它可以是直接跳转，即跳转目标是作为指令的一部分编码地；也可以是间接跳转，即跳转目标是从寄存器内或内存位置中导出地。

  - | 指令           | 同义名 | 跳转条件                                  | 描述                 |
    | -------------- | ------ | ----------------------------------------- | -------------------- |
    | `jmp Label`    |        | 1                                         | 直接跳转             |
    | `jmp *Operand` |        | 1                                         | 间接跳转             |
    | `je Label`     | `jz`   | `ZF`                                      | 相等/零              |
    | `jne Label`    | `jnz`  | `-ZF`                                     | 不相等/非零          |
    | `js Label`     |        | `SF`                                      | 负数                 |
    | `jns Label`    |        | `-SF`                                     | 非负数               |
    | `jg Label`     | `jnle` | $\sim (SF~\textasciicircum OF)\& \sim ZF$ | 大于(有符号>)        |
    | `jge Label`    | `jnl`  | $\sim (SF~\textasciicircum OF)$           | 大于或等于(有符号>=) |
    | `jl Label`     | `jnge` | $SF~\textasciicircum OF$                  | 小于(有符号<)        |
    | `jle Label`    | `jng`  | $(SF~\textasciicircum OF) | ZF$           | 小于或等于(有符号<=) |
    | `ja Label`     | `jnbe` | $\sim CF~\&~\sim~ZF$                      | 超过(无符号>)        |
    | `jae Label`    | `jnb`  | $-CF$                                     | 超过或相等(无符号>=) |
    | `jb Label`     | `jnae` | $CF$                                      | 低于(无符号<)        |
    | `jbe Label`    | `jna`  | $CF|ZF$                                   | 低于或相等(无符号<=) |

### 用条件控制来实现条件分支

- 将条件表达式和语句从`C`语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。

### 用条件传送来实现条件分支

- 是心啊条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条执行路径上执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效。
- 一种替代的策略是使用数据的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从总选取一个。

### 条件传送指令

- 同条件跳转不同，处理器无需预测测试的结果就可以执行条件传送。处理器只是读源值（可能是从内存中），检查条件码，然后要么更新目的寄存器，要么保持不变。

- | 指令          | 同义名    | 传送条件                                 | 描述                    |
  | ------------- | --------- | ---------------------------------------- | ----------------------- |
  | `cmove  S,R`  | `cmoovz`  | $ZF$                                     | 相等/零                 |
  | `cmovne  S,R` | `comovnz` | $\sim ZF$                                | 不相等/非零             |
  | `cmovs  S,R`  |           | $SF$                                     | 负数                    |
  | `cmovns  S,R` |           | $\sim SF$                                | 非负数                  |
  | `cmovg  S,R`  | `cmovnle` | $\sim~(SF~\textasciicircum OF)\&\sim ZF$ | 大于（有符号>)          |
  | `cmovge  S,R` | `cmovnl`  | $\sim(SF ~\textasciicircum OF)$          | 大于或等于（有符号>=）  |
  | `cmovl  S,R`  | `cmovnge` | $SF~\textasciicircum OF$                 | 小于（有符号<）         |
  | `cmovle  S,R` | `cmovng`  | $(SF~\textasciicircum OF)|ZF$            | 小于或等于（有符号<=)   |
  | `cmova  S,R`  | `cmovnbe` | $\sim CF~\& \sim ZF$                     | 超过（无符号>）         |
  | `cmovae  S,R` | `cmovnb`  | $ \sim CF$                               | 超过或相等（无符号>=）  |
  | `cmovb  S,R`  | `coovnae` | $CF$                                     | 低于（无符号<）         |
  | `cmovbe  S,R` | `cmovna`  | $CF|ZF$                                  | 低于或相等（无符号<= ） |

### 循环

- C语言提供了多种循环结构，即`do-while`、`while`和`for`。汇编中没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果。

#### do-while 循环

- 循环体至少会执行一次。

#### while循环

- 第一种翻译方法，称之为跳转到中间(`jump to middle`)，它执行一个无条件跳转跳到循环结尾处的测试，以此来执行初始的测试。
- 第二种翻译方法，称之为`guarded-do`，首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为`do-while`循环。
- for循环类似

#### switch语句

- switch（开关）语句可以根据一个整数索引值进行多重分支（`multiway branching`）。

## 过程



​    
