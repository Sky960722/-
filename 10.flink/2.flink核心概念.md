##  核心概念

### 并行度（`Parallelism`）

#### 并行子任务和并行度

- 一个特定算子的子任务（`subtask`）的个数被称之为其并行度（`parallelism`）。这样，包含并行子任务的数据流，就是并行数据流，它需要多个分区（`stream partition`）来分配并行任务。一般情况下，一个流程序的并行度，可以认为就是其所有算子中最大的并行度。一个程序中，不同的算子可能具有不同的并行度。

#### 并行度的设置

- 在`Flink`中，可以用不同的方法来设置并行度，它们的有效范围和优先级别也是不同的。

##### 代码中设置

- 在代码中，可以很简单地在算子后跟着调用`setParallelism()`方法，来设置当前算子的并行度：

  ~~~
  stream.map(word -> Tuple2.of(word, 1L)).setParallelism(2);
  ~~~

  - 这种方式设置的并行度，只针对当前算子有效

  - 我们也可以直接调用执行环境的setParallelism()方法，全局设定并行度：

    ~~~
    env.setParallelism(2);
    ~~~

    - 这样代码中所有算子，默认的并行度就都为2了。我们一般不会在程序中设置全局并行度，因为如果在程序中对全局并行度进行硬编码，会导致无法动态扩容。

##### 提交应用时设置

- 使用flink run命令提交应用时，可以增加-p参数来指定当前应用程序执行的并行度，它的作用类似于执行环境的全局设置

  ~~~
  bin/flink run –p 2 –c com.atguigu.wc.SocketStreamWordCount ./FlinkTutorial-1.0-SNAPSHOT.jar
  ~~~

##### 配置文件中设置

- 还可以直接在集群的配置文件`flink-conf.yaml`中直接更改默认并行度：

  ~~~
  parallelism.default: 2
  ~~~

- 这个设置对于整个集群上提交的所有作业有效，初始值为1。

- 无论在代码中设置、还是提交时的-p参数，都不是必须的；所以在没有指定并行度的时候，就会采用配置文件中的集群默认并行度。

- 在开发环境中，没有配置文件，默认并行度就是当前机器的CPU核心数。

### 算子链（`Operator Chain`）

#### 算子间的数据传输

- 一个数据流在算子之间传输数据的形式可以是一对一（`one-to-one`）的直通（`forwarding`）模式，也可以是打乱的重分区（`redistributing`）模式，具体是哪一种形式，取决于算子的种类。

##### 一对一（`One-to-one`，`forwarding`）

- 这种模式下，数据流维护着分区以及元素的顺序。`map`、`filter`、`flatMap`等算子都是这种`one-to-one`的对应关系。这种关系类似于`Spark`中的窄依赖。

#### 重分区（`Redistributing`）

- 在这种模式下，数据流的分区会发生改变。每一个算子的子任务，会根据数据传输的策略，把数据发送到不同的下游目标任务。这些传输方式都会引起重分区的过程，这一过程类似于`Spark`中的`shuffle`。

#### 合并算子链

- 在`Flink`中，并行度相同的一对一（`one to one`）算子操作，可以直接链接在一起形成一个“大”的任务（`task`），这样原来的算子就成为了真正任务里的一部分，这样的技术被称为“算子链”（`Operator Chain`）。

- `Flink`默认会按照算子链的原则进行链接合并，如果我们想要禁止合并或者自行定义，也可以在代码中对算子做一些特定的设置：

  ~~~
  // 禁用算子链
  .map(word -> Tuple2.of(word, 1L)).disableChaining();
  
  // 从当前算子开始新链
  .map(word -> Tuple2.of(word, 1L)).startNewChain()
  ~~~

### 任务槽（`Task Slots`）

- `Flink`中每一个`TaskManager`都是一个`JVM`进程，它可以启动多个独立的线程，来并行执行多个子任务（`subtask`）。
- 很显然，`TaskManager`的计算资源是有限的，并行的任务越多，每个线程的资源就会越少。为了控制并发量，我们需要在`TaskManager`上对每个任务运行所占用的资源做出明确的划分，这就是所谓的任务槽（`task slots`）。
- 每个任务槽（`task slot`）其实表示了`TaskManager`拥有计算资源的一个固定大小的子集。这些资源就是用来独立执行一个子任务的。

#### 任务槽数量的设置

- 在`Flink`的`/opt/module/flink-1.17.0/conf/flink-conf.yaml`配置文件中，可以设置`TaskManager`的`slot`数量，默认是`1`个`slot`。

  ~~~
  taskmanager.numberOfTaskSlots: 8
  ~~~

- 需要注意的是，`slot`目前仅仅用来隔离内存，不会涉及`CPU`的隔离。在具体应用时，可以将`slot`数量配置为机器的`CPU`核心数，尽量避免不同任务之间对`CPU`的竞争。这也是开发环境默认并行度设为机器`CPU`数量的原因。

#### 任务对任务槽的共享

- 在同一个作业中，不同任务节点的并行子任务，可以放到同一个`slot`上执行

- 默认情况下，`Flink`是允许子任务共享`slot`的。如果我们保持`sink`任务并行度为1不变，而作业提交时设置全局并行度为`6`，那么前两个任务节点就会各自有`6`个并行子任务，整个流处理程序则有`13`个子任务。只要属于同一个作业，那么对于不同任务节点（算子）的并行子任务，就可以放到同一个`slot`上执行。

- `slot`共享另一个好处就是允许我们保存完整的作业管道。这样一来，即使某个`TaskManager`出现故障宕机，其他节点也可以完全不受影响，作业的任务可以继续执行。

- `Flink`默认是允许`slot`共享的，如果希望某个算子对应的任务完全独占一个`slot`，或者只有某一部分算子共享`slot`，我们也可以通过设置“``slot`共享组”手动指定

  ~~~
  .map(word -> Tuple2.of(word, 1L)).slotSharingGroup("1");
  ~~~

  - 这样，只有属于同一个`slot`共享组的子任务，才会开启`slot`共享；不同组之间的任务是完全隔离的，必须分配到不同的`slot`上。在这种场景下，总共需要的`slot`数量，就是各个`slot`共享组最大并行度的总和。

#### 任务槽和并行度的关系

- 任务槽和并行度都跟程序的并行执行有关，但两者是完全不同的概念。
- 简单来说任务槽是静态的概念，是指`TaskManager`具有的并发执行能力，可以通过参数`taskmanager.numberOfTaskSlots`进行配置；而并行度是动态概念，也就是`TaskManager`运行程序时实际使用的并发能力，可以通过参数`parallelism.default`进行配置。
- 整个流处理程序的并行度，就应该是所有算子并行度中最大的那个，这代表了运行程序需要的`slot`数量。



