# 运输层

- 运输层位于应用层和网络层之间，是分层的网络体系结构的重要部分。分为`TCP`和`UDP`运输层协议。

## 概念

- 运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信功能。应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无无须考虑承载这些报文的物理基础设施的细节。

### 运输层概述

- `UDP`和`TCP`提供了两种截然不同的可用运输层协议。
  - `UDP`（用户数据报协议）为调用它的应用程序提供了一种不可靠、无连接的服务。
  - 另一种是`TCP`（传输控制协议），它为调用它的应用程序提供了一种可靠的面向连接的服务。

### 网络层概述

- 因特网网络层协议有一个名字叫`IP`，即网际协议。`IP`为主机之间提供了逻辑通信。`IP`的服务模型是尽力而为交付服务。

## 多路复用与多路分解

### 定义

- 将主机间交付扩展到进程间交付被称为运输层的多路复用与多路分解。
- 将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。
- 在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用。

### 要求

1. 套接字有唯一标识符
2. 每个报文段有特殊字段来指示该报文段所要交付到的套接字。这些特殊字段是源端口号字段和目的端口号字段（`UDP`报文段和`TCP`报文段还有其他的一些字段）。

### 无连接的多路复用与多路分解

- 一个`UDP`套接字是由一个二元组全面标识的，该二元组包含一个目的`IP`地址和一个目的端口号。
- 因此，如果两个`UDP`报文段有不同的源`IP`地址或源端口号，但具有相同的目的`IP`地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程。

### 面向连接的多路复用与多路分解

- `TCP`套接字是由一个四元组(源`IP`地址，源端口号，目的`IP`地址，目的端口号)来标识的。
- 因此，当一个`TCP`报文段从网络到达一台主机时，该主机使用全部`4`个值来将报文段定向（分解）到相应的套接字。

## 无连接运输：`UDP`

- `UDP`从应用进程得到数据，附加上用于多路复用/分解服务的源和目的端口号字段，以及两个其他的小字段，然后将形成的报文段交给网络层。网络层将该运输层报文封装到一个`IP`数据报中，然后尽力而为地尝试将此报文段交付给接收主机。如果该报文段到达接收主机，`UDP`使用目的端口号将报文段中的数据交付给正确的应用进程。值得注意的是，使用`UDP`时，在发送报文段之前，发送发和接收方的运输层实体之间没有握手。正因为如此，`UDP`被称为无连接的。

### `UDP`特点

- 关于发送什么数据以及何时发送的应用层控制更为精细
- 无须连接建立
- 无连接状态
- 分组首部开销小

### `UDP`报文段结构

- 应用层数据占用`UDP`报文段的数据字段。UDP首部只有4个字段，每个字段由两个字节组成。分别是源端口号，目的端口号，长度，检验和。然后是应用数据。
  - 源端口号，目的端口号：通过端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程。
  - 长度字段：指示了在UDP报文段中的字节数（首部加数据）。因为数据字段的长度在一个UDP段中不同于在另一个段中，故需要一个明确的长度。
  - 检验和：接收方使用检验和来检查在该报文段中是否出现了差错。

### `UDP`检验和

- UDP检验和提供了差错检验功能。检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变。

#### 原因

- 不能保证源和目的之间的所有链路都提供差错检测；这就是说，也许这些链路中的一条可能使用没有差错检测的协议。
- 此外，即使报文段经链路正确地传输，当报文段存储在某台路由器的内存中时，也可能引入比特差错。
- 在机无法确保链路的可靠性，又无法确保内存中的差错检测的情况下，如果端到端数据传输服务要提差错检测，UDP就必须在端到端基础上在运输层提供差错检测。这是一个在系统设计中被称颂的端到端原则的例子。

#### 端到端原则

- 该原则表述为因为某种功能必须基于端到端实现：与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或几乎没有价值的。

### 总结

- 虽然UDP提供差错检测，但它对差错恢复无能为力。UDP的某种实现只是丢弃受损的报文段，其他实现是将受损的报文段交给应用进程并给出警告。

## 可靠数据传输原理

- 可靠数据传输协议实现的服务抽象：数据可以通过一条可靠的信道进行传输 。借助于可靠信道，传输数据比特就不会受到损坏或丢失，而且所有数据都是按照其发送顺序进行交付。

### 实现原理

1. 完全可靠信道的可靠数据传输
   - 发送端调用rdt_send(data)事件接受来自较高层的数据，产生一个包含该数据的分组，并将分组发送到信道中
   - 接收端通过rdt_rev(packet)事件从底层信道接收一个分组，从分组中取出数据，并将数据上传给较高层。
   - 在这个简单的协议中，一个单元数据与一个分组没差别。而且，所有分组是从发送方流向接收方；有了完全可靠的信道，接收端就不需要提供任何反馈信息给发送方，因为不必担心出现差错。
2. 经具有比特差错信道的可靠数据传输
   - 在计算机网络中，基于这样重传机制的可靠数据传输协议称为自动重传请求（`Automatic Repeat reQuest`,`ARQ`）协议
     - 重要的是，`ARQ`协议中还需要另外三种协议功能来处理存在比特差错的情况
       - 差错检测
       - 接收方反馈
       - 重传
     - 发送端有两个状态。
       - 第一个状态：等待来自上层的调用
         - 当rdt_send(data)事件出现时，发送方将产生一个包含待发送数据的分组，带有检验和。并转到第二种状态
       - 第二个状态：等待ACK或NAK
         - 发送方协议等待来自接收方的ACK或NAK分组。如果收到一个ACK分组，则发送方知道最近发送的分组已被正确接收，因此协议返回到等待来自上层的数据的状态。如果收到一个NAK分组，该协议重传上一个分组并等待接收方为响应重传分组而回送的ACK和NAK。
     - 当发送方处于等待ACK或NAK的状态时，它不能从上层获得更多的数据。因此，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。由于这种行为，这种协议被称为停等协议。
     - 接收方只有单一状态
       - 当分组到达时，接收方要么回答一个ACK，要么回答一个NAK，这取决于收到的分组是否受损。
     - 如何处理受损的ACK和NAK
       - 数据分组中添加一新字段，让发送方对其数据分组编号，即将发送数据分组的序号放在该字段。于是，接收方只需要检查序号即可确定收到的分组是否一次重传。
     - 这个协议比起上面的协议，因为多了一个人序号。导致接收方和发送方的状态是上面的两倍。
     - 发送方状态
       - 等待来自上层的调用 0
       - 等待ACK或NAK 0
       - 等待来自上层的调用 1
       - 等待ACK或NAK 1
     - 接收方状态
       - 等待来自下层的 0
       - 等待来自下层的 1
3. 经具有比特差错的丢包信道的可靠数据传输
   - 重传是一个万能灵药。基于事件的重传机制，需要一个倒计数定时器，在一个给定的时间量过期后，可中断发送方。因此，发送方需要做到
     1. 每次发送一个分组时，便启动一个定时器
     2. 响应定时器中断
     3. 终止定时器
   - 因为分组序号在0和1之间较低，因此rdt3.0有时被称为比特交替协议。

## 流水线可靠数据传输协议

- 不以停等方式运行，允许发送方发送多个分组而无须等待确认。因为许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中。故这种技术被称为流水线。
  - 必须增加序列范围。
  - 协议的发送方和接收方两端也许不得不缓存多个分组
  - 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。
    - 解决流水线的差错恢复有两种基本方法：
      - 回退N步（Go-Back-N）
      - 选择重传（Selective Repeat，SR）

### 回退N步

- 在回退N步协议中，允许发送发发送多个分组而不需要等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。
- 已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口。随着协议的运行，该窗口在序号空间内向前滑动。因此，N常被称为窗口长度，GBN协议也常被称为滑动窗口协议。

### 选择重传

- 选择重传（`SR`）协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。
- SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢失分组皆被收到位置，这时才可以将一批分组按序交付给上层。

## 面向连接的运输：TCP

- TCP被称为是面向连接的，这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互握手，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。
- TCP连接提供的是全双工服务：如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可在从进程B流向进程A的同时，也从进程A流向进程B。
- 客户端首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文段作为响应。前两个报文段不承载有效荷载，也就是不包含应用层数据；而第三个报文段可以承载有效荷载。这种连接建立过程被称为三次握手。
- TCP可从缓存中取出并放入报文段中的数据受限于最大报文段长度（Maximum Segment Size，MSS）。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的最大传输单元（Maximum Transmission Unit，MTU））来设置。设置该MSS要保证一个TCP报文段（当封装在一个IP数据报中）加上`TCP/IP`首部长度（通常40字节）将适合单个链路层帧。

### TCP报文段结构

- 32比特的序号字段和32比特的确认号字段。这些字段被TCP发送方和接收方用来实现可靠数据传输服务
- 16比特的接收窗口字段：该字段用于流量控制。
- 4比特的首部长度字段：该字段指示了以32比特的字为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的。
- 可选与变长的选项字段，该字段用于发送方与接收方协商最大报文段长度(`MSS`)时，放在高速网络环境下用作窗口调节因子时使用。
- 6比特的标志字段：ACK比特用于确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认。

#### 1.序号和确认号

- TCP报文段首部中两个最重要的字段是序号字段和确认号字段。
- TCP把数据看成一个无结构的、有序的字节流。一个报文段的序号（sequence number for a segment）是该报文段首字节的字节流编号。

### 往返时间的估计与超时

- TCP采用超时/重传机制来处理报文段的丢失问题。超时间隔必须大于该连接的往返时间(RTT)，即从一个报文段发出到它被确认的时间。否则会造成不必要的重传。

#### 1.估计往返时间

- 报文段的样本RTT（表示为SampleRTT）就是从某报文段被发出（即交给IP）到对该报文段的呢确认被收到之间的时间量。
- 估计一个典型的RTT，自然要采取某种对SampleRTT取平均的办法。TCP维持一个SampleRTT均值（称为EstimatedRTT）。$EstimatedRTT=(1-α)*EsimatedRTT+α*SampleRTT$
- 除了估算RTT外，测量RTT的变化也是有价值的。定义RTT偏差DevRTT，用于估算SampleRTT一般会偏离EsimatedRTT的程度：$DevRTT=(1-β)*DevRTT+β*|SampleRTT-EsimatedRTT|$

#### 2.设置和管理重传超时间隔

- 将超时时间间隔设为EstimatedRTT加上一定余量。当SampleRTT值波动较大时，这个余量应该大些；当波动段较小时，这个余量应该小些。$TimeoutInterval=EstimatedRTT+4*DevRTT$

## TCP连接管理

- 第一步：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中不包含应用层数据。但是在报文段的首部中的一个标志位（即SYN比特）被置为1。因此，这个特殊报文段被称为SYN报文段。
- 第二步：一旦包含TCP SYN报文段中的IP数据报到达服务器主机，服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。
- 第三步：在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认。
- 为了创建该连接，在两台主机之间发送了3个分组。由于这个原因，这种连接创建过程通常被称为3次握手。
- 客户应用进程发出一个关闭连接命令。这会引起客户TCP向服务器进程发送一个特殊的TCP报文段。这个特殊的报文段让其首部中的一个标志位即FIN比特被设置为1。当服务器接收到该报文段后，就向发送方回送一个确认报文段。然后，服务器发送它自己的终止报文段，其FIN比特被置为1。最后，该客户对这个服务器的终止报文段进行确认。此时，这两台主机上用于该连接的所有资源都被释放了。
